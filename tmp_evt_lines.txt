/**
 * å¢å¼ºçš„äº‹ä»¶æ€»çº¿ç³»ç»Ÿ
 * æ”¯æŒReactä¸Phaserä¹‹é—´çš„åŒå‘é€šä¿¡
 * ç¬¦åˆ CLAUDE.md æ¶æ„è¦æ±‚å’Œäº‹ä»¶é©±åŠ¨è®¾è®? */

import type {
  GameDomainEvent,
  GameEventHandler,
  EnhancedGameEvent,
  GameEventMetadata,
} from '../contracts/events/GameEvents';
import { EventPriority } from '../contracts/events/GameEvents';

export interface EventSubscription {
  id: string;
  handler: GameEventHandler;
  priority: EventPriority;
  once?: boolean;
  context?: string; // ç”¨äºåŒºåˆ†Reactæˆ–Phaserä¸Šä¸‹æ–?}

export interface EventBusOptions {
  maxListeners?: number;
  enableLogging?: boolean;
  enableMetrics?: boolean;
  queueSize?: number;
}

export class EventBus {
  private listeners: Map<string, EventSubscription[]> = new Map();
  private eventQueue: EnhancedGameEvent[] = [];
  private isProcessing = false;
  private subscriptionIdCounter = 0;
  private options: Required<EventBusOptions>;

  // æ€§èƒ½ç›‘æ§
  private metrics = {
    eventsPublished: 0,
    eventsProcessed: 0,
    averageProcessingTime: 0,
    lastEventTime: 0,
  };

  constructor(options: EventBusOptions = {}) {
    this.options = {
      maxListeners: options.maxListeners ?? 100,
      enableLogging:
        options.enableLogging ?? process.env.NODE_ENV === 'development',
      enableMetrics: options.enableMetrics ?? true,
      queueSize: options.queueSize ?? 1000,
    };
  }

  /**
   * è®¢é˜…äº‹ä»¶
   */
  public subscribe<T extends GameDomainEvent>(
    eventType: T['type'],
    handler: GameEventHandler<T>,
    options: {
      priority?: EventPriority;
      once?: boolean;
      context?: string;
    } = {}
  ): string {
    const subscriptionId = `sub_${++this.subscriptionIdCounter}`;

    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }

    const eventListeners = this.listeners.get(eventType)!;

    // æ£€æŸ¥ç›‘å¬å™¨æ•°é‡é™åˆ¶
    if (eventListeners.length >= this.options.maxListeners) {
      throw new Error(
        `Maximum listeners (${this.options.maxListeners}) exceeded for event: ${eventType}`
      );
    }

    const subscription: EventSubscription = {
      id: subscriptionId,
      handler: handler as GameEventHandler,
      priority: options.priority ?? EventPriority.NORMAL,
      once: options.once ?? false,
      context: options.context,
    };

    eventListeners.push(subscription);

    // æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆé«˜ä¼˜å…ˆçº§åœ¨å‰ï¼‰
    eventListeners.sort((a, b) => b.priority - a.priority);

    if (this.options.enableLogging) {
      console.log(
        `[EventBus] Subscribed to ${eventType} (ID: ${subscriptionId}, Context: ${options.context || 'unknown'})`
      );
    }

    return subscriptionId;
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  public unsubscribe(subscriptionId: string): boolean {
    for (const [eventType, subscriptions] of this.listeners.entries()) {
      const index = subscriptions.findIndex(sub => sub.id === subscriptionId);
      if (index !== -1) {
        subscriptions.splice(index, 1);

        // å¦‚æœæ²¡æœ‰ç›‘å¬å™¨äº†ï¼Œæ¸…ç†Map
        if (subscriptions.length === 0) {
          this.listeners.delete(eventType);
        }

        if (this.options.enableLogging) {
          console.log(
            `[EventBus] Unsubscribed from ${eventType} (ID: ${subscriptionId})`
          );
        }

        return true;
      }
    }
    return false;
  }

  /**
   * å–æ¶ˆæŒ‡å®šäº‹ä»¶ç±»å‹çš„æ‰€æœ‰è®¢é˜?   */
  public unsubscribeAll(eventType: GameDomainEvent['type']): number {
    const subscriptions = this.listeners.get(eventType);
    if (subscriptions) {
      const count = subscriptions.length;
      this.listeners.delete(eventType);

      if (this.options.enableLogging) {
        console.log(
          `[EventBus] Unsubscribed all (${count}) listeners from ${eventType}`
        );
      }

      return count;
    }
    return 0;
  }

  /**
   * å‘å¸ƒäº‹ä»¶ï¼ˆåŒæ­¥ï¼‰
   */
  public publish(
    event: GameDomainEvent,
    metadata?: Partial<GameEventMetadata>
  ): void {
    const enhancedEvent: EnhancedGameEvent = {
      ...event,
      metadata: {
        id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        timestamp: new Date(),
        source: metadata?.source || 'unknown',
        priority: metadata?.priority || EventPriority.NORMAL,
        persistent: metadata?.persistent || false,
        broadcast: metadata?.broadcast || true,
        ...metadata,
      },
    };

    this.metrics.eventsPublished++;

    if (this.options.enableLogging) {
      console.log(`[EventBus] Publishing event: ${event.type}`, enhancedEvent);
    }

    // ç«‹å³å¤„ç†äº‹ä»¶
    this.processEvent(enhancedEvent);
  }

  /**
   * å‘å¸ƒäº‹ä»¶ï¼ˆå¼‚æ­¥é˜Ÿåˆ—ï¼‰
   */
  public async publishAsync(
    event: GameDomainEvent,
    metadata?: Partial<GameEventMetadata>
  ): Promise<void> {
    const enhancedEvent: EnhancedGameEvent = {
      ...event,
      metadata: {
        id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        timestamp: new Date(),
        source: metadata?.source || 'unknown',
        priority: metadata?.priority || EventPriority.NORMAL,
        persistent: metadata?.persistent || false,
        broadcast: metadata?.broadcast || true,
        ...metadata,
      },
    };

    // æ£€æŸ¥é˜Ÿåˆ—å¤§å°?    if (this.eventQueue.length >= this.options.queueSize) {
      console.warn(
        `[EventBus] Event queue full (${this.options.queueSize}), dropping oldest event`
      );
      this.eventQueue.shift();
    }

    this.eventQueue.push(enhancedEvent);
    this.metrics.eventsPublished++;

    // å¦‚æœæ²¡æœ‰åœ¨å¤„ç†ï¼Œå¼€å§‹å¤„ç†é˜Ÿåˆ?    if (!this.isProcessing) {
      await this.processEventQueue();
    }
  }

  /**
   * å¤„ç†å•ä¸ªäº‹ä»¶
   */
  private processEvent(event: EnhancedGameEvent): void {
    const startTime = performance.now();
    const subscriptions = this.listeners.get((event as any).type) || [];

    if (subscriptions.length === 0) {
      if (this.options.enableLogging) {
        console.warn(
          `[EventBus] No listeners for event: ${(event as any).type}`
        );
      }
      return;
    }

    // å¤„ç†æ‰€æœ‰è®¢é˜…è€?    const toRemove: string[] = [];

    for (const subscription of subscriptions) {
      try {
        const result = subscription.handler(event as any);

        // å¤„ç†å¼‚æ­¥å¤„ç†å™?        if (result instanceof Promise) {
          result.catch(error => {
            console.error(
              `[EventBus] Async handler error for ${(event as any).type}:`,
              error
            );
          });
        }

        // æ ‡è®°ä¸€æ¬¡æ€§è®¢é˜…ä»¥ä¾›ç§»é™?        if (subscription.once) {
          toRemove.push(subscription.id);
        }
      } catch (error) {
        console.error(
          `[EventBus] Handler error for ${(event as any).type}:`,
          error
        );
      }
    }

    // ç§»é™¤ä¸€æ¬¡æ€§è®¢é˜?    toRemove.forEach(id => this.unsubscribe(id));

    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    if (this.options.enableMetrics) {
      const processingTime = performance.now() - startTime;
      this.metrics.eventsProcessed++;
      this.metrics.averageProcessingTime =
        (this.metrics.averageProcessingTime *
          (this.metrics.eventsProcessed - 1) +
          processingTime) /
        this.metrics.eventsProcessed;
      this.metrics.lastEventTime = Date.now();
    }
  }

  /**
   * å¤„ç†äº‹ä»¶é˜Ÿåˆ—
   */
  private async processEventQueue(): Promise<void> {
    if (this.isProcessing) {
      return;
    }

    this.isProcessing = true;

    try {
      while (this.eventQueue.length > 0) {
        const event = this.eventQueue.shift()!;

        // æŒ‰ä¼˜å…ˆçº§å¤„ç†
        if (event.metadata.priority >= EventPriority.HIGH) {
          this.processEvent(event);
        } else {
          // ä½ä¼˜å…ˆçº§äº‹ä»¶å¯ä»¥åœ¨ä¸‹ä¸€ä¸ªå¾®ä»»åŠ¡ä¸­å¤„ç?          await new Promise(resolve => setTimeout(resolve, 0));
          this.processEvent(event);
        }
      }
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * è·å–äº‹ä»¶ç›‘å¬å™¨ç»Ÿè®¡ä¿¡æ?   */
  public getListenerStats(): Record<string, number> {
    const stats: Record<string, number> = {};

    for (const [eventType, subscriptions] of this.listeners.entries()) {
      stats[eventType] = subscriptions.length;
    }

    return stats;
  }

  /**
   * è·å–æ€§èƒ½æŒ‡æ ‡
   */
  public getMetrics() {
    return { ...this.metrics };
  }

  /**
   * æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨å’Œé˜Ÿåˆ?   */
  public destroy(): void {
    this.listeners.clear();
    this.eventQueue.length = 0;
    this.isProcessing = false;

    if (this.options.enableLogging) {
      console.log('[EventBus] EventBus destroyed');
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰æŒ‡å®šäº‹ä»¶çš„ç›‘å¬å™¨
   */
  public hasListeners(eventType: GameDomainEvent['type']): boolean {
    const subscriptions = this.listeners.get(eventType);
    return subscriptions ? subscriptions.length > 0 : false;
  }

  /**
   * è·å–æŒ‡å®šäº‹ä»¶çš„ç›‘å¬å™¨æ•°é‡
   */
  public getListenerCount(eventType: GameDomainEvent['type']): number {
    const subscriptions = this.listeners.get(eventType);
    return subscriptions ? subscriptions.length : 0;
  }
}



